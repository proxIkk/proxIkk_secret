import { Mutex } from 'async-mutex';
import { 
    BotContext, 
    ParsedPumpCreateData, 
    CoinPosition, 
    createCoinPosition 
} from '../types/types';
import logger from '../utils/logger';
import { 
    Keypair, 
    PublicKey, 
    LAMPORTS_PER_SOL,
    ComputeBudgetProgram,
    Transaction,
    SystemProgram,
    SYSVAR_RENT_PUBKEY,
    AccountInfo,
    TransactionInstruction,
    VersionedTransaction,
} from '@solana/web3.js';
import bs58 from 'bs58';
import { waitForTransactionConfirmation } from '../utils/transaction-utils';
import {
    getAssociatedTokenAddressSync, 
    createAssociatedTokenAccountInstruction,
    TOKEN_PROGRAM_ID,
    ASSOCIATED_TOKEN_PROGRAM_ID 
} from '@solana/spl-token';
import axios from 'axios';
import BN from 'bn.js';
import { recordTradeStats } from '../utils/stats';
import { rpcWithRetry } from '../utils/rpc-utils';
import { IdlAccounts } from '@coral-xyz/anchor'; 
import { Pump } from '../types/pump_idl';
import { Bundle } from 'jito-ts/dist/sdk/block-engine/types';
import Decimal from 'decimal.js';

// <<<--- –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è --- >>>
let isShuttingDown = false;

// –ú—å—é—Ç–µ–∫—Å –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–æ–Ω–µ—Ç
const activeCoinLock = new Mutex();

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const RPC_TIMEOUT_MS = 5000; // 5 —Å–µ–∫—É–Ω–¥
// –£–±–∏—Ä–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è —Ä–µ—Ç—Ä–∞–µ–≤ –ø–æ–∫—É–ø–∫–∏, —Ç–∞–∫ –∫–∞–∫ rpcWithRetry –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏–Ω–∞—á–µ
// const BUY_RETRY_DELAY_MS = 200;
// const MAX_BUY_RETRIES = 5;

// <<<--- –ù–æ–≤—ã–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –∫—Ä–∏–≤–æ–π --- >>>
const BONDING_CURVE_FETCH_RETRIES = 5; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ø—ã—Ç–æ–∫ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –∫—Ä–∏–≤–æ–π
const BONDING_CURVE_FETCH_DELAY_MS = 300; // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏ (–º—Å)

// <<<--- –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è PDA –∏ –∞–∫–∫–∞—É–Ω—Ç–æ–≤ Pump.fun (–ü–†–û–í–ï–†–ò–¢–¨ –ê–î–†–ï–°–ê!) --- >>>
const GLOBAL_ACCOUNT_PUBKEY = new PublicKey("4wTV1YmiEkRvAtNtsSGPtUrqRYQMe5SKy2uB4Jjaxnjf"); // <<<--- –£–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω
const FEE_RECIPIENT_PUBKEY = new PublicKey("62qc2CNXwrYqQScmEdiZFFAnJR262PxWEuNQtxfafNgV"); // <<<--- –ù–æ–≤—ã–π –∞–¥—Ä–µ—Å!
const MPL_TOKEN_METADATA_PROGRAM_ID = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
const SYSTEM_PROGRAM_ID = SystemProgram.programId;

// <<<--- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ö–µ–º—É Borsh --- >>>
// const BONDING_CURVE_LAYOUT = borsh.struct([...]);

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –¥–∞–Ω–Ω—ã—Ö, –ò–ó–í–õ–ï–ß–ï–ù–ù–´–• –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞ –∫—Ä–∏–≤–æ–π
// –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª—è –∏–∑ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ Pump
interface BondingCurveData {
    virtualTokenReserves: BN; 
    virtualSolReserves: BN;
    realTokenReserves: BN;
    realSolReserves: BN;
    tokenTotalSupply: BN;
    complete: boolean;
}

// <<<--- –¢–∏–ø –∞–∫–∫–∞—É–Ω—Ç–∞: –ü—Ä–æ–±—É–µ–º bondingCurve —Å –º–∞–ª–µ–Ω—å–∫–æ–π –±—É–∫–≤—ã --- >>>
type BondingCurveAccount = IdlAccounts<Pump>['bondingCurve']; // –ò–∑–º–µ–Ω—è–µ–º –Ω–∞ camelCase

/**
 * –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–æ–≤–æ–≥–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Å–æ–±—ã—Ç–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –º–æ–Ω–µ—Ç—ã.
 * @param eventData –î–∞–Ω–Ω—ã–µ –æ–± –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω–æ–π –º–æ–Ω–µ—Ç–µ.
 * @param context –ö–æ–Ω—Ç–µ–∫—Å—Ç –±–æ—Ç–∞.
 */
export async function handleNewMintEvent(eventData: ParsedPumpCreateData, context: BotContext): Promise<void> {
    // <<<--- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–ª–∞–≥–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è --- >>>
    if (isShuttingDown) {
        logger.info({ mint: eventData.mint }, "Shutting down, skipping new mint event.");
        return;
    }
    try {
        logger.trace({ 
            mint: eventData.mint, 
            currentActiveCoin: context.activeCoin ? context.activeCoin.mint : null, 
            mutexLocked: activeCoinLock.isLocked() 
        }, 'handleNewMintEvent triggered');
        
        logger.trace({ 
            mint: eventData.mint, 
            creator: eventData.creator, 
            name: eventData.tokenName, 
            symbol: eventData.tokenSymbol
          }, `üöÄ Potential new token detected!`);

        await activeCoinLock.runExclusive(async () => {
            try {
                if (context.activeCoin) {
                    logger.trace({ 
                        currentMint: context.activeCoin.mint, 
                        skippedMint: eventData.mint 
                    }, 'Already processing a coin, skipping new mint');
                    return; 
                }

                logger.debug({ mint: eventData.mint }, 'Acquired lock, starting processing...');

                try {
                    const newCoin = createCoinPosition(eventData);
                    newCoin.state = 'buying'; 
                    context.activeCoin = newCoin; 

                    logger.info({ mint: newCoin.mint }, 'Filters passed, attempting buy...');
                    
                    const buySuccess = await executeBuy(newCoin, context);

                    if (!buySuccess) {
                        logger.warn({ mint: newCoin.mint }, 'Buy execution failed or unconfirmed, resetting active coin.');
                        context.activeCoin = null;
                    }
                } catch (buyError) {
                    logger.error({ mint: eventData.mint, error: buyError }, 'Error during buy phase within lock, resetting active coin.');
                    context.activeCoin = null; 
                }
            } catch (innerError) {
                logger.error({ mint: eventData.mint, error: innerError }, 'Error inside runExclusive block');
                if (context.activeCoin?.mint === eventData.mint) { 
                    context.activeCoin = null;
                }
            }
        });
        

    } catch (outerError) {
         logger.error({ mint: eventData.mint, error: outerError }, 'Error in handleNewMintEvent (outer catch)');
    }
}

/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–∫—É–ø–∫—É —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Anchor.
 */
export async function executeBuy(coin: CoinPosition, context: BotContext): Promise<boolean> {
    try {
        const tradingWalletKp = context.tradingWallet;
        const mintPublicKey = new PublicKey(coin.mint);
        const bondingCurvePublicKey = new PublicKey(coin.bondingCurve);
        const connection = context.solanaConnection;
        const pumpFunProgram = context.pumpFunProgram; // <<<--- Program<Pump>
        const amountInSol = context.config.buyAmountSol;
        const amountInLamportsBigInt = BigInt(Math.floor(amountInSol * LAMPORTS_PER_SOL));
        const slippageBps = context.config.slippageBps;
        const tipAccount = new PublicKey(context.config.jitoTipAccountPubkey);

        // 1. –ü–æ–ª—É—á–∞–µ–º ATA –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ
        const ataAddress = getAssociatedTokenAddressSync(
            mintPublicKey, tradingWalletKp.publicKey, false, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID
        );
        logger.debug({ mint: coin.mint, ata: ataAddress.toBase58() }, "Calculated ATA address");

        // 2. –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫—Ä–∏–≤–æ–π —Å–≤—è–∑—ã–≤–∞–Ω–∏—è —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏ –¥–ª—è "not found"
        logger.debug({ mint: coin.mint }, `Fetching bonding curve data (max ${BONDING_CURVE_FETCH_RETRIES} retries)...`);
        let bondingCurveData: BondingCurveAccount | null = null;
        let lastFetchError: any = null;

        for (let attempt = 1; attempt <= BONDING_CURVE_FETCH_RETRIES; attempt++) {
            try {
                logger.trace({ mint: coin.mint, attempt }, "Attempting to fetch bonding curve data...");
                bondingCurveData = await rpcWithRetry(
                   () => pumpFunProgram.account.bondingCurve.fetch(bondingCurvePublicKey, 'processed'),
                   `fetchBC attempt ${attempt} (${bondingCurvePublicKey.toBase58()})`
                );
                if (bondingCurveData) {
                    logger.trace({ mint: coin.mint, attempt, bondingCurveData }, "Successfully fetched bonding curve data.");
                    lastFetchError = null; 
                    break; // –£—Å–ø–µ—Ö, –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞
                } else {
                     // –ú–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω–æ, –Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–µ–º
                     logger.warn({ mint: coin.mint, attempt }, "Fetched bonding curve data but it was null/undefined. This is unexpected. Retrying...");
                     lastFetchError = new Error("Fetched bonding curve data but it was null/undefined.");
                     // –Ø–≤–Ω–æ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º bondingCurveData –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
                     bondingCurveData = null; 
                     // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –∑–∞–¥–µ—Ä–∂–∫–µ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
                }
            } catch (fetchError: any) {
                lastFetchError = fetchError; 
                const errorString = String(fetchError?.message || fetchError).toLowerCase();
                const isNotFoundError = errorString.includes("account does not exist") ||
                                         errorString.includes("account not found") ||
                                         errorString.includes("could not find account");

                if (isNotFoundError && attempt < BONDING_CURVE_FETCH_RETRIES) {
                    logger.warn({ mint: coin.mint, attempt, error: fetchError.message }, `Bonding curve not found, retrying in ${BONDING_CURVE_FETCH_DELAY_MS}ms...`);
                    await new Promise(resolve => setTimeout(resolve, BONDING_CURVE_FETCH_DELAY_MS));
                    continue; // <<<--- –ö–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ: –ü–†–û–î–û–õ–ñ–ê–ï–ú —Ü–∏–∫–ª –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–∏
                } else {
                    logger.error({ mint: coin.mint, attempt, error: fetchError.message }, "Failed to fetch bonding curve data due to non-recoverable error or max retries reached.");
                    bondingCurveData = null; // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è
                    break; // –í—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞ –ø—Ä–∏ –Ω–µ–∏—Å–ø—Ä–∞–≤–∏–º–æ–π –æ—à–∏–±–∫–µ –∏–ª–∏ –∏—Å—á–µ—Ä–ø–∞–Ω–∏–∏ –ø–æ–ø—ã—Ç–æ–∫
                }
            }
             // –ï—Å–ª–∏ –º—ã –¥–æ—à–ª–∏ —Å—é–¥–∞ (–Ω–µ —á–µ—Ä–µ–∑ break), –∑–Ω–∞—á–∏—Ç –±—ã–ª–∞ –æ—à–∏–±–∫–∞ 'null/undefined' 
             // –∏–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞ 'not found' –±–µ–∑ break –≤—ã—à–µ. –ñ–¥–µ–º –ø–µ—Ä–µ–¥ —Ä–µ—Ç—Ä–∞–µ–º.
             if (attempt < BONDING_CURVE_FETCH_RETRIES) {
                  logger.warn({ mint: coin.mint, attempt }, `Waiting ${BONDING_CURVE_FETCH_DELAY_MS}ms before next fetch attempt...`);
                  await new Promise(resolve => setTimeout(resolve, BONDING_CURVE_FETCH_DELAY_MS));
             }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª–∏ –ª–∏ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ –ø–æ–ª—É—á–µ–Ω—ã –ü–û–°–õ–ï –¶–ò–ö–õ–ê
        if (!bondingCurveData) {
            logger.error({ mint: coin.mint, error: lastFetchError?.message || "Unknown Error" }, "Failed to fetch bonding curve data after all retries. Aborting buy.");
            coin.buyError = `Failed to fetch bonding curve: ${lastFetchError?.message || "Retries exceeded"}`;
            coin.state = 'failed'; 
            await recordTradeStats(coin, context); 
            context.activeCoin = null; 
            return false; // <<<--- –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤—ã—Ö–æ–¥, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ –ø–æ–ª—É—á–µ–Ω—ã
        }
        // –ï—Å–ª–∏ –º—ã –∑–¥–µ—Å—å, bondingCurveData —Ç–æ—á–Ω–æ –Ω–µ null
        logger.trace({ mint: coin.mint, bondingCurveData }, "Fetched bonding curve data successfully.");

        // 3. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≤—ã–∑–æ–≤–∞ buy (—Ç–µ–ø–µ—Ä—å –¢–û–õ–¨–ö–û —Å –≤–∞–ª–∏–¥–Ω—ã–º–∏ bondingCurveData)
        const virtualSolReserves = bondingCurveData.virtualSolReserves; // –¢–∏–ø BN –∏–∑ IDL
        const virtualTokenReserves = bondingCurveData.virtualTokenReserves; // –¢–∏–ø BN –∏–∑ IDL
        const amountInLamportsBN = new BN(amountInLamportsBigInt.toString());

        if (virtualSolReserves.isZero() || virtualTokenReserves.isZero()) {
             logger.error({ mint: coin.mint, vsr: virtualSolReserves.toString(), vtr: virtualTokenReserves.toString() }, "Cannot calculate buy params: bonding curve reserves are zero.");
             throw new Error("Cannot calculate buy params: bonding curve reserves are zero.");
        }
        const expectedTokensOutBN = virtualTokenReserves.mul(amountInLamportsBN).div(virtualSolReserves.add(amountInLamportsBN));
        const maxSolCostBN = amountInLamportsBN;
        const slippageNumerator = new BN(10000).sub(new BN(slippageBps));
        const slippageDenominator = new BN(10000);
        const minTokenAmountBN = expectedTokensOutBN.mul(slippageNumerator).div(slippageDenominator);

        logger.info({
            mint: coin.mint, amountInSol: amountInSol,
            expectedTokensOut: expectedTokensOutBN.toString(), slippageBps: slippageBps,
            minTokenAmountOut: minTokenAmountBN.toString(), maxSolCost: maxSolCostBN.toString()
        }, "Calculated buy parameters with slippage");

        // <<<--- –ü–æ–ª—É—á–∞–µ–º –ü–†–ê–í–ò–õ–¨–ù–´–ô –ê–¢–ê –¥–ª—è –∫—Ä–∏–≤–æ–π –±–æ–Ω–¥–∏–Ω–≥–∞ --- >>>
        const associatedBondingCurveAddress = getAssociatedTokenAddressSync(
            mintPublicKey, 
            bondingCurvePublicKey, // <<<--- –í–ª–∞–¥–µ–ª–µ—Ü - –∫—Ä–∏–≤–∞—è –±–æ–Ω–¥–∏–Ω–≥–∞!
            true, // <<<--- –°—Ç–∞–≤–∏–º true, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ PDA-–∞–∫–∫–∞—É–Ω—Ç
            TOKEN_PROGRAM_ID, 
            ASSOCIATED_TOKEN_PROGRAM_ID
        );

        // 4. –§–æ—Ä–º–∏—Ä—É–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –ø–æ–∫—É–ø–∫–∏ —Å .accountsStrict() –∏ camelCase
        logger.debug({ mint: coin.mint }, "Building buy instruction with Anchor...");
        let buyInstruction: TransactionInstruction;
        try {
            buyInstruction = await pumpFunProgram.methods
                .buy( minTokenAmountBN, maxSolCostBN )
                .accountsStrict({
                    global: GLOBAL_ACCOUNT_PUBKEY,
                    feeRecipient: FEE_RECIPIENT_PUBKEY,
                    mint: mintPublicKey,
                    bondingCurve: bondingCurvePublicKey,
                    associatedBondingCurve: associatedBondingCurveAddress,
                    associatedUser: ataAddress, 
                    user: tradingWalletKp.publicKey,
                    systemProgram: SYSTEM_PROGRAM_ID,
                    tokenProgram: TOKEN_PROGRAM_ID,
                    rent: SYSVAR_RENT_PUBKEY,
                    eventAuthority: PublicKey.findProgramAddressSync([Buffer.from("__event_authority")], context.pumpFunProgram.programId)[0],
                    program: context.pumpFunProgram.programId,
                })
                .instruction();
             logger.trace({ mint: coin.mint, buyIxData: buyInstruction.data.toString('hex') }, "Built buy instruction");
        } catch (buildError: any) {
             logger.error({ mint: coin.mint, error: buildError.message, stack: buildError.stack }, "Failed to build Anchor buy instruction.");
             throw buildError;
        }

        // 5. Compute Units –∏ Jito Tip
        let unitsConsumed = context.config.defaultComputeUnits;
        // <<<--- –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ --- >>>
        const tipLamports = context.config.jitoFixedTipLamports;
        logger.debug({ mint: coin.mint, units: unitsConsumed, fixedTip: tipLamports }, "Using fixed Jito tip");

        // 6. –°–±–æ—Ä–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        const mainTx = new Transaction();
        mainTx.add(ComputeBudgetProgram.setComputeUnitLimit({ units: unitsConsumed }));
        // –í—Å–µ–≥–¥–∞ –¥–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é —Å–æ–∑–¥–∞–Ω–∏—è ATA (–æ–Ω–∞ –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–∞)
        mainTx.add(createAssociatedTokenAccountInstruction(tradingWalletKp.publicKey, ataAddress, tradingWalletKp.publicKey, mintPublicKey, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID));
        mainTx.add(buyInstruction);
        // <<<--- –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ --- >>>
        mainTx.add(SystemProgram.transfer({ 
            fromPubkey: tradingWalletKp.publicKey, 
            toPubkey: tipAccount, 
            lamports: BigInt(tipLamports) // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        }));
        mainTx.recentBlockhash = context.latestBlockhash;
        mainTx.feePayer = tradingWalletKp.publicKey;
        
        mainTx.sign(tradingWalletKp);
        const serializedMainTx = bs58.encode(mainTx.serialize({ requireAllSignatures: false }));

        // 7. –û—Ç–ø—Ä–∞–≤–∫–∞ Jito –±–∞–Ω–¥–ª–∞ —á–µ—Ä–µ–∑ gRPC (–û–î–ù–û–ô —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏)
        logger.info({ mint: coin.mint }, "Sending Jito bundle via gRPC (single tx with tip)...");
        let buySignature: string | null = bs58.encode(mainTx.signature!);
        try { 
            // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç Bundle –∏–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            const txBuffer = mainTx.serialize({ requireAllSignatures: false });
            const versioned = VersionedTransaction.deserialize(txBuffer);
            const bundle = new Bundle([versioned], 5); // –õ–∏–º–∏—Ç –≤ 5 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –¥–ª—è –±–∞–Ω–¥–ª–∞
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–Ω–¥–ª —á–µ—Ä–µ–∑ gRPC –∫–ª–∏–µ–Ω—Ç
            const resultSend = await context.jitoClient.sendBundle(bundle);
            
            if ('ok' in resultSend && resultSend.ok === false) {
                const error = resultSend.error;
                // –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ gRPC
                logger.error({ 
                    mint: coin.mint, 
                    error: error.message,
                    errorCode: error.code,
                    errorDetails: error.details
                }, "Failed to send Jito bundle via gRPC (detailed)");
                throw new Error(`Failed to send Jito bundle via gRPC: ${error.message}, code: ${error.code}, details: ${error.details}`);
            }
            
            const bundleId = resultSend.value;
            logger.info({ mint: coin.mint, bundleId }, "Jito bundle sent via gRPC successfully.");
        } catch (gRpcError: any) { 
             const errorMsg = gRpcError.message || "Unknown gRPC error";
             logger.error({ mint: coin.mint, error: errorMsg }, "Failed to send Jito bundle via gRPC.");
             coin.buyError = `Jito gRPC Error: ${errorMsg}`;
             coin.state = 'failed';
             await recordTradeStats(coin, context);
             context.activeCoin = null;
             return false;
        }
        
        if (!buySignature) {
             logger.error({ mint: coin.mint }, "Failed to retrieve transaction signature after sending bundle (unexpected). Aborting buy.");
             coin.buyError = "Failed to retrieve signature post-bundle";
             coin.state = 'failed'; 
             await recordTradeStats(coin, context);
             context.activeCoin = null;
             return false;
        }

        // 8. –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        logger.info({ mint: coin.mint, signature: buySignature }, "Waiting for BUY transaction confirmation...");
        const confirmed = await waitForTransactionConfirmation(buySignature, connection, 'processed', 90);
        if (!confirmed) {
            logger.warn({ mint: coin.mint, signature: buySignature }, "BUY transaction confirmation failed or timed out ('processed').");
            try {
                const txDetails = await connection.getTransaction(buySignature, { maxSupportedTransactionVersion: 0, commitment: 'confirmed' });
                logger.warn({ mint: coin.mint, signature: buySignature, txDetails }, "Transaction details (if available after timeout)");
                coin.buyError = `Confirmation timeout ('processed'). Details: ${JSON.stringify(txDetails?.meta?.err || 'N/A')}`;
            } catch (detailError: any) {
                 logger.error({ mint: coin.mint, signature: buySignature, error: detailError.message }, "Failed to get transaction details after confirmation timeout ('processed').");
                 coin.buyError = "Confirmation timeout ('processed'), failed to get details ('confirmed').";
            }
            coin.state = 'failed'; 
            await recordTradeStats(coin, context);
            context.activeCoin = null;
            return false; 
        }

        // 9. –£—Å–ø–µ—à–Ω–∞—è –ø–æ–∫—É–ø–∫–∞
        coin.buyTxSignature = buySignature;
        coin.state = 'tracking';

        // <<<--- –î–æ–±–∞–≤–ª—è–µ–º —Ü–∏–∫–ª –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞ --- >>>
        const BALANCE_FETCH_RETRIES = 5; // –ú–∞–∫—Å. –ø–æ–ø—ã—Ç–æ–∫
        const BALANCE_RETRY_DELAY_MS = 300; // –ü–∞—É–∑–∞ –º–µ–∂–¥—É –ø–æ–ø—ã—Ç–∫–∞–º–∏
        let balanceFetched = false;
        logger.debug({ mint: coin.mint, ata: ataAddress.toBase58() }, `Fetching token balance (max ${BALANCE_FETCH_RETRIES} retries)...`);

        for (let attempt = 1; attempt <= BALANCE_FETCH_RETRIES; attempt++) {
            try {
                logger.trace({ mint: coin.mint, attempt }, `Attempt ${attempt} to fetch token balance...`);
                const tokenBalanceResponse = await rpcWithRetry(
                    () => connection.getTokenAccountBalance(ataAddress, 'processed'),
                    `getTokenBalance attempt ${attempt} (${ataAddress.toBase58()})`
                );

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ amount —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –∏ –Ω–µ null/undefined
                if (tokenBalanceResponse?.value?.amount !== null && tokenBalanceResponse?.value?.amount !== undefined) {
                    coin.tokensHeld = tokenBalanceResponse.value.amount;
                    logger.info({ mint: coin.mint, balance: coin.tokensHeld }, "Token balance fetched successfully.");
                    balanceFetched = true;
                    break; // –£—Å–ø–µ—Ö, –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞
                } else {
                    logger.warn({ mint: coin.mint, attempt, response: tokenBalanceResponse }, `Attempt ${attempt}: Could not retrieve token balance amount ('processed'), retrying...`);
                }
            } catch (balanceError: any) {
                logger.warn({ 
                    mint: coin.mint, 
                    attempt,
                    ata: ataAddress.toBase58(), 
                    error: balanceError.message 
                }, `Attempt ${attempt}: Failed to fetch token balance ('processed'), retrying...`);
                 // –ù–µ –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞, –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞
            }
            
            // –ï—Å–ª–∏ –Ω–µ –≤—ã—à–ª–∏ –∏–∑ —Ü–∏–∫–ª–∞ (—Ç.–µ. –Ω–µ –±—ã–ª–æ break), –∂–¥–µ–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
            if (attempt < BALANCE_FETCH_RETRIES) {
                await new Promise(resolve => setTimeout(resolve, BALANCE_RETRY_DELAY_MS));
            }
        }

        // –ï—Å–ª–∏ –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–æ–ø—ã—Ç–æ–∫ –±–∞–ª–∞–Ω—Å –Ω–µ –ø–æ–ª—É—á–µ–Ω, —Å—Ç–∞–≤–∏–º UNKNOWN
        if (!balanceFetched) {
             logger.error({ mint: coin.mint, attempts: BALANCE_FETCH_RETRIES }, "Failed to fetch token balance after all retries. Setting to UNKNOWN.");
             coin.tokensHeld = 'UNKNOWN'; 
        }
        // --- >>> –ë–∞–ª–∞–Ω—Å –ø–æ–ª—É—á–µ–Ω (–∏–ª–∏ –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π) <<< ---

        logger.info({ mint: coin.mint, sig: coin.buyTxSignature, tokensHeld: coin.tokensHeld }, 'BUY successful (Anchor)!');
        await startActiveCoinTracking(coin, context);
        return true;

    } catch (error) {
        // ... (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫) ...
         return false;
    }
}

// <<<--- –†–µ–∞–ª–∏–∑—É–µ–º –§—É–Ω–∫—Ü–∏—é –ü—Ä–æ–≤–µ—Ä–∫–∏ –£—Å–ª–æ–≤–∏–π –ü—Ä–æ–¥–∞–∂–∏ --- >>>
/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏—è –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏ –∞–∫—Ç–∏–≤–Ω–æ–π –º–æ–Ω–µ—Ç—ã.
 */
async function checkSellConditions(coin: CoinPosition, context: BotContext): Promise<void> {
    logger.trace({ mint: coin.mint, state: coin.state }, "Checking sell conditions...");

    if (coin.state === 'selling' || coin.state === 'sold' || coin.state === 'failed') {
        return;
    }

    if (coin.currentMarketCap === undefined || coin.initialMarketCap === undefined || !coin.lastMarketCapUpdateTime) {
        logger.warn({ mint: coin.mint }, "Skipping sell check due to missing market cap data.");
        return;
    }

    const config = context.config;
    const currentMarketCap = coin.currentMarketCap;
    const initialMarketCap = coin.initialMarketCap;
    const maxMarketCap = coin.maxMarketCap || initialMarketCap;

    let sellReason: string | null = null;
    let sellAmountPercentage: number | 'ALL' = 'ALL';

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –£—Å–ª–æ–≤–∏–π
    if (coin.creatorSold) { // TODO: –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø—Ä–æ–¥–∞–∂ —Å–æ–∑–¥–∞—Ç–µ–ª—è –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ
        // sellReason = `Creator sell detected`; 
        // sellAmountPercentage = 'ALL';
    } else if (currentMarketCap < initialMarketCap * (1 - config.entrySlPct / 100)) {
        sellReason = `Entry SL hit (${config.entrySlPct}%)`;
    } else if (currentMarketCap < maxMarketCap * (1 - config.maxMcSlPct / 100)) {
        sellReason = `Max MC SL hit (${config.maxMcSlPct}%)`;
    } else if (coin.maxMarketCapUpdateTime && (Date.now() - coin.maxMarketCapUpdateTime.getTime() > config.stagnationTimeoutSec * 1000)) {
        // –°—Ä–∞–±–æ—Ç–∞–µ—Ç, –µ—Å–ª–∏ –ø—Ä–æ—à–ª–æ –±–æ–ª—å—à–µ stagnationTimeoutSec —Å–µ–∫—É–Ω–¥ —Å —Ç–µ—Ö –ø–æ—Ä, –∫–∞–∫ –±—ã–ª –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω –ø–æ—Å–ª–µ–¥–Ω–∏–π maxMarketCap
        sellReason = `Stagnation Timeout (No new Max MC for ${config.stagnationTimeoutSec}s)`;
    } else if (!coin.soldTp2 && currentMarketCap >= initialMarketCap * config.tp2McMult) {
        sellReason = `TP2 hit (>= ${config.tp2McMult}x)`;
        coin.soldTp2 = true;
        sellAmountPercentage = 'ALL';
    } else if (!coin.soldTp1 && currentMarketCap >= initialMarketCap * config.tp1McMult) {
        sellReason = `TP1 hit (>= ${config.tp1McMult}x)`;
        coin.soldTp1 = true;
        sellAmountPercentage = config.tp1SellPct;
    }

    if (sellReason) {
        logger.info({ 
            mint: coin.mint, 
            reason: sellReason, 
            currentMC: currentMarketCap, 
            initialMC: initialMarketCap,
            maxMC: maxMarketCap,
            sellPercentage: sellAmountPercentage
        }, `Sell condition met! Attempting sell.`);
        
        // <<<--- –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–∏—á–∏–Ω—É –ø—Ä–æ–¥–∞–∂–∏ –ü–ï–†–ï–î –≤—ã–∑–æ–≤–æ–º executeSell --- >>>
        coin.sellReason = sellReason; 
        coin.state = 'selling'; 
        executeSell(coin, context, sellAmountPercentage).catch(err => {
             logger.error({ mint: coin.mint, error: err }, "executeSell promise rejected unexpectedly");
             // –ü–æ–ø—ã—Ç–∞–µ–º—Å—è –≤–µ—Ä–Ω—É—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –µ—Å–ª–∏ executeSell –Ω–µ —Å–º–æ–≥ —ç—Ç–æ–≥–æ —Å–¥–µ–ª–∞—Ç—å
             if(coin.state === 'selling') coin.state = 'tracking'; 
        }); 
    }
}

/**
 * –ó–∞–ø—É—Å–∫–∞–µ—Ç –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ Market Cap –¥–ª—è –∞–∫—Ç–∏–≤–Ω–æ–π –º–æ–Ω–µ—Ç—ã.
 */
async function startActiveCoinTracking(coin: CoinPosition, context: BotContext): Promise<void> {
    logger.info({ mint: coin.mint }, 'Starting active tracking...');

    if (context.trackingIntervalId) {
        clearInterval(context.trackingIntervalId);
        context.trackingIntervalId = null;
    }

    const bondingCurvePublicKey = new PublicKey(coin.bondingCurve);
    const connection = context.solanaConnection;
    const pumpFunProgram = context.pumpFunProgram; // –¢–∏–ø Program<Pump>

    const fetchAndUpdateMC = async () => {
        // <<<--- –õ–æ–≥ –≤ –Ω–∞—á–∞–ª–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ --- >>>
        logger.trace({ mint: coin.mint, state: coin.state }, "fetchAndUpdateMC interval triggered"); 
        
        if (context.activeCoin?.mint !== coin.mint || (coin.state !== 'tracking' && coin.state !== 'buying')) { // Allow fetch during 'buying' state initially
             logger.warn({ expectedMint: coin.mint, actualMint: context.activeCoin?.mint, state: coin.state}, 'Stopping tracking or pre-fetch for inactive/changed/sold coin.');
             if(context.trackingIntervalId) clearInterval(context.trackingIntervalId);
             context.trackingIntervalId = null;
             return;
        }
                
        try {
            const ataAddress = getAssociatedTokenAddressSync(new PublicKey(coin.mint), context.tradingWallet.publicKey);
            
            // <<<--- –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫—Ä–∏–≤–æ–π –∏ –±–∞–ª–∞–Ω—Å ('confirmed') --- >>>
            logger.trace({ mint: coin.mint }, "Fetching curve data and balance concurrently...");
            const [curveAccountInfoResult, balanceResponseResult] = await Promise.allSettled([
                rpcWithRetry(
                    () => pumpFunProgram.account.bondingCurve.fetch(bondingCurvePublicKey, 'confirmed'),
                    `fetchBC_track(${bondingCurvePublicKey.toBase58()})`
                ),
                rpcWithRetry(
                    () => connection.getTokenAccountBalance(ataAddress, 'confirmed'),
                    `getTokenBalance_track(${ataAddress.toBase58()})`
                )
            ]);

            const now = new Date();
            let curveDataFetched = false;
            let balanceFetched = false;

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–∞–Ω–Ω—ã—Ö –∫—Ä–∏–≤–æ–π
            if (curveAccountInfoResult.status === 'fulfilled' && curveAccountInfoResult.value) {
                const curveAccountInfo = curveAccountInfoResult.value as BondingCurveAccount; // –ü—Ä–∏–≤–æ–¥–∏–º —Ç–∏–ø
                coin.lastKnownCurveData = curveAccountInfo; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –∫—Ä–∏–≤–æ–π
                coin.lastCurveDataFetchTime = now;
                curveDataFetched = true;
                logger.trace({ mint: coin.mint }, "Fetched bonding curve data for MC update and pre-fetch."); 
                
                // <<< –†–∞—Å—á–µ—Ç Market Cap –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤–Ω—É—Ç—Ä—å —ç—Ç–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ >>>
                 const decodedData: BondingCurveAccount = curveAccountInfo; // –ò—Å–ø–æ–ª—å–∑—É–µ–º —É–∂–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                 const bondingCurveData: BondingCurveData = {
                     virtualTokenReserves: decodedData.virtualTokenReserves,
                     virtualSolReserves: decodedData.virtualSolReserves,
                     realTokenReserves: decodedData.realTokenReserves,
                     realSolReserves: decodedData.realSolReserves,
                     tokenTotalSupply: decodedData.tokenTotalSupply,
                     complete: decodedData.complete
                 };
                 if (bondingCurveData.virtualTokenReserves.gtn(0) && bondingCurveData.virtualSolReserves.gtn(0) && bondingCurveData.tokenTotalSupply?.gtn(0)) {
                    const marketCapLamportsBN = bondingCurveData.tokenTotalSupply.mul(bondingCurveData.virtualSolReserves).div(bondingCurveData.virtualTokenReserves);
                    const marketCapDecimal = new Decimal(marketCapLamportsBN.toString()).div(LAMPORTS_PER_SOL);
                    const currentMarketCapNumber = marketCapDecimal.toNumber(); 
                    
                    logger.info({ 
                        mint: coin.mint, 
                        currentMarketCap: marketCapDecimal.toString(),
                        previousMarketCap: coin.currentMarketCap ?? 'N/A',
                        maxMarketCap: (coin.maxMarketCap || coin.initialMarketCap) ?? 'N/A'
                    }, 'Market Cap updated.'); 

                    // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –º–æ–Ω–µ—Ç—ã (—Ö—Ä–∞–Ω–∏–º –∫–∞–∫ number)
                    coin.currentMarketCap = currentMarketCapNumber;
                    coin.lastMarketCapUpdateTime = now; // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—â–µ–µ –≤—Ä–µ–º—è `now`
                    if (!coin.initialMarketCap) {
                        coin.initialMarketCap = currentMarketCapNumber;
                        coin.maxMarketCap = currentMarketCapNumber; // <<< –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º maxMarketCap
                        coin.maxMarketCapUpdateTime = now;      // <<< –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Ä–µ–º—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–∞–∫—Å–∏–º—É–º–∞
                    } else if (currentMarketCapNumber > (coin.maxMarketCap || 0)) { // <<< –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–π –º–∞–∫—Å–∏–º—É–º
                         coin.maxMarketCap = currentMarketCapNumber;
                         coin.maxMarketCapUpdateTime = now;     // <<< –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –ø—Ä–∏ –Ω–æ–≤–æ–º –º–∞–∫—Å–∏–º—É–º–µ
                    }
                } else {
                     logger.warn({ mint: coin.mint }, "Cannot calculate Market Cap: bonding curve reserves are zero.");
                }
                 // <<< –ö–æ–Ω–µ—Ü —Ä–∞—Å—á–µ—Ç–∞ Market Cap >>>

            } else {
                 logger.warn({ mint: coin.mint, error: (curveAccountInfoResult as PromiseRejectedResult).reason }, "Could not fetch bonding curve data for tracking/pre-fetch.");
                 // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å
            }

            // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –±–∞–ª–∞–Ω—Å–∞
            if (balanceResponseResult.status === 'fulfilled' && balanceResponseResult.value?.value?.amount !== null && balanceResponseResult.value?.value?.amount !== undefined) {
                coin.lastKnownBalance = balanceResponseResult.value.value.amount; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–∞–ª–∞–Ω—Å
                coin.lastBalanceFetchTime = now;
                balanceFetched = true;
                logger.trace({ mint: coin.mint, balance: coin.lastKnownBalance }, "Fetched token balance for pre-fetch.");
            } else {
                const errorReason = balanceResponseResult.status === 'rejected' ? (balanceResponseResult as PromiseRejectedResult).reason : "Amount is null/undefined";
                logger.warn({ mint: coin.mint, error: errorReason }, "Could not fetch token balance for pre-fetch.");
                // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–π –±–∞–ª–∞–Ω—Å, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
            }
            // <<<--- –ö–æ–Ω–µ—Ü –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ –∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ --- >>>

            // <<<--- –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –ø—Ä–æ–¥–∞–∂–∏ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –µ—Å—Ç—å —Å–≤–µ–∂–∏–µ –¥–∞–Ω–Ω—ã–µ –∫—Ä–∏–≤–æ–π --- >>>
            if (curveDataFetched && coin.state === 'tracking') { // Check conditions only if in tracking state
                await checkSellConditions(coin, context);
            }

        } catch (error: any) {
             const errorDetails = error instanceof Error ? { message: error.message, stack: error.stack, name: error.name } : { errorInfo: error };
             logger.error({ mint: coin.mint, error: errorDetails }, "Error during Market Cap tracking interval.");
        }
    };

    // Initial fetch might happen quickly after buy, ensure ATA exists potentially
    await new Promise(resolve => setTimeout(resolve, 500)); // Small delay before first fetch
    await fetchAndUpdateMC(); // –ü–µ—Ä–≤—ã–π –≤—ã–∑–æ–≤ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
    context.trackingIntervalId = setInterval(fetchAndUpdateMC, context.config.mcCheckIntervalMs); // –ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞

    logger.warn({ mint: coin.mint }, "Creator sell tracking not implemented yet.");
}

/**
 * –í—ã–ø–æ–ª–Ω—è–µ—Ç –ø—Ä–æ–¥–∞–∂—É —Ç–æ–∫–µ–Ω–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Anchor.
 */
export async function executeSell(
    coin: CoinPosition, 
    context: BotContext, 
    amountPercentage: number | 'ALL',
    isShutdown: boolean = false
): Promise<boolean> {
     logger.info({ mint: coin.mint, amountPercentage, reason: coin.sellReason, isShutdown }, "Attempting sell (Anchor)...");
     coin.state = 'selling';
     try {
         const tradingWalletKp = context.tradingWallet;
         const mintPublicKey = new PublicKey(coin.mint);
         const bondingCurvePublicKey = new PublicKey(coin.bondingCurve);
         const connection = context.solanaConnection;
         const pumpFunProgram = context.pumpFunProgram;
         const slippageBps = context.config.slippageBps;
         const tipAccount = new PublicKey(context.config.jitoTipAccountPubkey);
         const ataAddress = getAssociatedTokenAddressSync(mintPublicKey, tradingWalletKp.publicKey, false, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID);

         // <<<--- –ò–ó–ú–ï–ù–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ RPC-–∑–∞–ø—Ä–æ—Å–æ–≤ --- >>>
         // 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞
         if (coin.lastKnownBalance === undefined || coin.lastKnownBalance === null || !coin.lastBalanceFetchTime) {
             logger.error({ mint: coin.mint }, "Cannot execute sell: lastKnownBalance is missing. Aborting sell.");
             coin.sellError = "Missing cached balance before sell";
             coin.state = 'tracking'; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ, –≤–æ–∑–º–æ–∂–Ω–æ, –¥–∞–Ω–Ω—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø–æ–∑–∂–µ
             return false;
         }
         // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–µ–∂–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –Ω–æ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)
         const balanceAgeMs = Date.now() - coin.lastBalanceFetchTime.getTime();
         if (balanceAgeMs > context.config.mcCheckIntervalMs * 2.5) { // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ä—à–µ ~2.5 –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤
             logger.warn({ mint: coin.mint, ageMs: balanceAgeMs }, "Cached balance is potentially too old. Consider aborting or increase fetch frequency.");
             // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å return false; –∑–¥–µ—Å—å –¥–ª—è –±–æ–ª—å—à–µ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
         }
         logger.debug({ mint: coin.mint, balance: coin.lastKnownBalance, ageMs: balanceAgeMs }, "Using cached token balance for sell.");
         coin.tokensHeld = coin.lastKnownBalance; // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
         const currentTokensHeldBigInt = BigInt(coin.lastKnownBalance);

         // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∫—Ä–∏–≤–æ–π
         if (!coin.lastKnownCurveData || !coin.lastCurveDataFetchTime) {
            logger.error({ mint: coin.mint }, "Cannot execute sell: lastKnownCurveData is missing. Aborting sell.");
            coin.sellError = "Missing cached curve data before sell";
            coin.state = 'tracking'; 
            return false;
        }
        const curveDataAgeMs = Date.now() - coin.lastCurveDataFetchTime.getTime();
        if (curveDataAgeMs > context.config.mcCheckIntervalMs * 2.5) { // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ä—à–µ ~2.5 –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤
             logger.warn({ mint: coin.mint, ageMs: curveDataAgeMs }, "Cached curve data is potentially too old. Consider aborting or increase fetch frequency.");
            // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å return false; –∑–¥–µ—Å—å –¥–ª—è –±–æ–ª—å—à–µ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        }
        logger.debug({ mint: coin.mint, ageMs: curveDataAgeMs }, "Using cached bonding curve data for sell.");
        // –ü—Ä–∏–≤–æ–¥–∏–º —Ç–∏–ø —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        const bondingCurveData = coin.lastKnownCurveData as BondingCurveAccount; 

        // 3. –†–∞—Å—á–µ—Ç—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
         if (currentTokensHeldBigInt === 0n) { 
             logger.info({ mint: coin.mint }, "Cached token balance is zero. Considering sell successful (no-op)."); 
             coin.state = 'sold'; 
             await recordTradeStats(coin, context); 
             if (context.activeCoin?.mint === coin.mint) context.activeCoin = null; // <<< –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –æ–±–Ω—É–ª—è–µ–º
             return true; 
         }

         // –†–∞—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
         let tokensToSellBigInt: bigint;
         if (amountPercentage === 'ALL') {
             tokensToSellBigInt = currentTokensHeldBigInt;
         } else {
             const sellPct = BigInt(Math.max(0, Math.min(100, amountPercentage)));
             tokensToSellBigInt = (currentTokensHeldBigInt * sellPct) / 100n;
             logger.warn({ mint: coin.mint }, "Partial sell percentage logic triggered.");
         }
          if (tokensToSellBigInt <= 0n) { 
             logger.warn({ mint: coin.mint, amountToSell: tokensToSellBigInt.toString(), percentage: amountPercentage }, "Calculated amount to sell is zero or negative. Skipping sell.");
             coin.state = 'tracking'; 
             return false;
         }
         const tokensToSellBN = new BN(tokensToSellBigInt.toString());
         logger.info({ mint: coin.mint, amountToSell: tokensToSellBN.toString() }, "Calculated tokens to sell (using cached balance).");

        // –†–∞—Å—á–µ—Ç min SOL out (–∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫—Ä–∏–≤–æ–π)
        const virtualSolReserves = bondingCurveData.virtualSolReserves;
        const virtualTokenReserves = bondingCurveData.virtualTokenReserves;
        if (virtualTokenReserves.isZero()) { 
             logger.error({ mint: coin.mint, vtr: virtualTokenReserves.toString() }, "Cannot calculate sell params (cached): virtual token reserves are zero.");
             coin.sellError = "Zero virtual token reserves (Cached Sell)";
             coin.state = 'tracking'; 
             return false; 
        }
        const solOutBN = virtualSolReserves.mul(tokensToSellBN).div(virtualTokenReserves.add(tokensToSellBN));
        const slippageNumerator = new BN(10000).sub(new BN(slippageBps));
        const slippageDenominator = new BN(10000);
        const minSolOutputBN = solOutBN.mul(slippageNumerator).div(slippageDenominator);
        logger.info({ mint: coin.mint, expectedSolOut: solOutBN.toString(), minSolOutput: minSolOutputBN.toString() }, "Calculated minimum SOL output (using cached curve data)"); 

        // <<<--- –ö–û–ù–ï–¶ –ò–ó–ú–ï–ù–ï–ù–ò–Ø: –î–∞–ª–µ–µ –∏–¥–µ—Ç –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ --- >>>

        // –ü–æ–ª—É—á–∞–µ–º –ü–†–ê–í–ò–õ–¨–ù–´–ô –ê–¢–ê –¥–ª—è –∫—Ä–∏–≤–æ–π –±–æ–Ω–¥–∏–Ω–≥–∞ (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
        const associatedBondingCurveAddress = getAssociatedTokenAddressSync(
            mintPublicKey, 
            bondingCurvePublicKey, 
            true, 
            TOKEN_PROGRAM_ID, 
            ASSOCIATED_TOKEN_PROGRAM_ID
        );
        logger.trace({ mint: coin.mint, associatedBondingCurve: associatedBondingCurveAddress.toBase58() }, "Calculated Associated Bonding Curve address (PDA) for sell");

         // 4. –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ sell —Å .accountsStrict() –∏ camelCase
         logger.debug({ mint: coin.mint }, "Building sell instruction (Anchor)...");
         let sellInstruction: TransactionInstruction;
         try {
             sellInstruction = await pumpFunProgram.methods
                 .sell( tokensToSellBN, minSolOutputBN )
                 .accountsStrict({
                    global: GLOBAL_ACCOUNT_PUBKEY,
                    feeRecipient: FEE_RECIPIENT_PUBKEY,
                    mint: mintPublicKey,
                    bondingCurve: bondingCurvePublicKey,
                    associatedBondingCurve: associatedBondingCurveAddress, 
                    associatedUser: ataAddress, 
                    user: tradingWalletKp.publicKey,
                    systemProgram: SYSTEM_PROGRAM_ID,
                    associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID, 
                    tokenProgram: TOKEN_PROGRAM_ID,
                    eventAuthority: PublicKey.findProgramAddressSync([Buffer.from("__event_authority")], context.pumpFunProgram.programId)[0],
                    program: context.pumpFunProgram.programId,
                 })
                 .instruction();
             logger.trace({ mint: coin.mint, sellIxData: sellInstruction.data.toString('hex') }, "Built sell instruction");
         } catch (buildError: any) {
              logger.error({ mint: coin.mint, error: buildError.message, stack: buildError.stack }, "Failed to build Anchor sell instruction."); 
              coin.sellError = `Build Sell Ix Error: ${buildError.message}`;
              coin.state = 'tracking'; return false;
         }

        // 5. Compute Units –∏ Jito Tip
        const unitsConsumed = context.config.defaultComputeUnits;
        const tipLamports = context.config.jitoFixedTipLamports;
        logger.debug({ mint: coin.mint, units: unitsConsumed, fixedTip: tipLamports }, "Using fixed Jito tip for sell");

        // 6. –°–±–æ—Ä–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        const finalSellTx = new Transaction();
        finalSellTx.add(ComputeBudgetProgram.setComputeUnitLimit({ units: unitsConsumed }));
        finalSellTx.add(sellInstruction);
        finalSellTx.add(SystemProgram.transfer({fromPubkey: tradingWalletKp.publicKey, toPubkey: tipAccount, lamports: BigInt(tipLamports) }));
        finalSellTx.recentBlockhash = context.latestBlockhash;
        finalSellTx.feePayer = tradingWalletKp.publicKey;
        finalSellTx.sign(tradingWalletKp);
        const rawSellTx = finalSellTx.serialize();

        // 7. –û—Ç–ø—Ä–∞–≤–∫–∞ Jito –±–∞–Ω–¥–ª–∞ —á–µ—Ä–µ–∑ gRPC
        logger.info({ mint: coin.mint }, "Sending Jito SELL bundle via gRPC...");
        let sellSignature: string | null = null;
        try { 
            // –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥–ø–∏—Å—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø–µ—Ä–µ–¥ –æ—Ç–ø—Ä–∞–≤–∫–æ–π
            sellSignature = bs58.encode(finalSellTx.signatures.find(s => s.publicKey.equals(tradingWalletKp.publicKey))!.signature!);
            
            // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç Bundle –∏–∑ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            const txBuffer = finalSellTx.serialize();
            const versioned = VersionedTransaction.deserialize(txBuffer);
            const bundle = new Bundle([versioned], 5); // –õ–∏–º–∏—Ç –≤ 5 —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –¥–ª—è –±–∞–Ω–¥–ª–∞
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–∞–Ω–¥–ª —á–µ—Ä–µ–∑ gRPC –∫–ª–∏–µ–Ω—Ç
            const resultSend = await context.jitoClient.sendBundle(bundle);
            
            if ('ok' in resultSend && resultSend.ok === false) {
                const error = resultSend.error;
                // –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ gRPC
                logger.error({ 
                    mint: coin.mint, 
                    error: error.message,
                    errorCode: error.code,
                    errorDetails: error.details
                }, "Failed to send Jito SELL bundle via gRPC (detailed)");
                throw new Error(`Failed to send Jito SELL bundle via gRPC: ${error.message}, code: ${error.code}, details: ${error.details}`);
            }
            
            const bundleId = resultSend.value;
            logger.info({ mint: coin.mint, bundleId }, "Jito SELL bundle sent via gRPC successfully.");
        } catch (gRpcError: any) { 
            const errorMsg = gRpcError.message || "Unknown gRPC error";
            logger.error({ mint: coin.mint, error: errorMsg }, "Failed to send Jito SELL bundle via gRPC.");
            coin.sellError = `Jito SELL gRPC Error: ${errorMsg}`;
            coin.state = 'tracking'; 
            return false; 
        }

        // 8. –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
        logger.info({ mint: coin.mint, signature: sellSignature }, "Waiting for SELL confirmation...");
        const sellConfirmed = await waitForTransactionConfirmation(
            sellSignature, 
            connection, 
            'processed', 
            90,
            isShutdown
        ); 
        if (!sellConfirmed) {
            logger.warn({ mint: coin.mint, signature: sellSignature, isShutdown }, `SELL transaction confirmation failed or timed out ('processed', timeout: ${isShutdown ? '30s' : '90s'}).`);
            try {
                const txDetails = await connection.getTransaction(sellSignature, { maxSupportedTransactionVersion: 0, commitment: 'confirmed' });
                logger.warn({ mint: coin.mint, signature: sellSignature, txDetails, isShutdown }, "Transaction details (if available after SELL timeout)");
                coin.sellError = `Sell Confirmation timeout ('processed', ${isShutdown ? '30s' : '90s'}). Details: ${JSON.stringify(txDetails?.meta?.err || 'N/A')}`;
            } catch (detailError: any) {
                 logger.error({ mint: coin.mint, signature: sellSignature, error: detailError.message, isShutdown }, "Failed to get transaction details after SELL confirmation timeout ('processed').");
                 coin.sellError = `Sell Confirmation timeout ('processed', ${isShutdown ? '30s' : '90s'}), failed to get details ('confirmed').`;
            }
            coin.state = 'tracking'; 
            return false; 
        }

        // 9. –£—Å–ø–µ—à–Ω–∞—è –ø—Ä–æ–¥–∞–∂–∞
        logger.info({ mint: coin.mint, sig: sellSignature, soldAmount: tokensToSellBN.toString() }, 'SELL successful (Anchor)!');
        coin.sellTxSignature = sellSignature;
         if (amountPercentage === 'ALL') {
              coin.state = 'sold';
              // <<< –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –æ–±–Ω—É–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –º–æ–Ω–µ—Ç—É >>>
              if (context.activeCoin?.mint === coin.mint) {
                  context.activeCoin = null; 
              }
          } else {
             logger.warn({ mint: coin.mint }, "Partial sell executed, coin.tokensHeld might be stale.");
             const remaining = currentTokensHeldBigInt - tokensToSellBigInt;
             coin.tokensHeld = remaining.toString();
         }
         await recordTradeStats(coin, context);
         if (amountPercentage === 'ALL') {
             coin.state = 'sold';
             context.activeCoin = null; 
         } else {
             coin.state = 'tracking'; 
         }
        return true;

     } catch (error) {
         logger.error({ mint: coin.mint, error }, "Unexpected error during executeSell");
         coin.state = 'tracking'; 
         return false;
     }
 } 

/**
 * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ñ–ª–∞–≥ –Ω–∞—á–∞–ª–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã.
 */
export function signalShutdown(): void {
    logger.info("Signalling shutdown...");
    isShuttingDown = true;
}

/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â—É—é –∞–∫—Ç–∏–≤–Ω—É—é –º–æ–Ω–µ—Ç—É (–µ—Å–ª–∏ –µ—Å—Ç—å).
 */
export function getActiveCoin(context: BotContext): CoinPosition | null {
    return context.activeCoin;
}
